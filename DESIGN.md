HTML

	The main two html pages in the templates folder are layout and home. The layout file utilizes jinja to create a layout for all of the other html pages to follow. This layout includes a black navigation bar at the top of the page, which displays different nav links depending on certain conditions, such as if the user is logged in or not. Another feature of this file is it gives every page the Harvard logo at the bottom of the screen, creating a visual for the website.

	The home page, as well as all of the other html pages, utilize the Jinja layout from layout.html to create one style for every single html page. I chose this because I was having trouble finding a way to pull data from a separate HTML page, and I realized creating a card structure would be much more effective at tackling this problem of showing post-specific information. However, while the other html pages have unique buttons or input fields, or they display some of the user’s data, the home page is very unique. The home page is designed so that each new post creates a “card” with all of the post’s corresponding information located on it. This was done by looping through purchaseInfo, which contained all of the specific information for each post. In each card are some specific elements, such as the name of the user, the title of the post, and the message. These elements are named by adding {{  loop.index  }} to them, which follows a method of naming variables via for loop, or by adding a value of “i” to each name, where “i” increases by 1 after each iteration. This allows the user to have access to a specific element instead of changing one element the same way in every post.

	With the like buttons, I used a Jinja variable to store information about each user and how they have liked or disliked a post. Then, following the same naming conventions as before, I named each button so that it could be specifically identified and used as needed. However, I gave the thumbs up/thumbs down buttons 3 different designs depending on how the user interacts with them. Firstly, if the user likes a post, it turns the like button blue and leaves the dislike button unchanged. If the user dislikes a post, it does the opposite. If the user neither likes nor dislikes a post, neither button will turn blue. This was done via Jinja if statements that utilized booleans inside the voted table that stated whether or not the user had liked that post or disliked it.

Lastly for the home page, I used a Jinja for loop with an if statement to display comments. The Jinja loop iterates through every entry in the comments table and checks if the post_id in the table matches the actual post id. If so, then the comment’s message would be displayed when the user clicked on the “Load Comments” button, which uses the bootstrap collapse/expand feature to create a more organized and appealing GUI.

Python

helpers.py

	This python page incorporates the apology and login_required functions from the finance problem set.

app.py

	This is the file where all the magic happens. My program uses Jinja and flask to operate, as well as several other libraries which are imported here. Additionally, this file contains different events based off of which element is selected in the program. The login(), logout(), and register() functions were modeled off of the finance problem set, but I made my own specifications that made the functions specific to my program, such as creating custom error messages and having them relate to my own elements, not the elements in the finance pset. Additionally, the register() function also checks the email of the user to make sure the email address is valid via regex. If so, it allows the user to proceed with registration, otherwise it informs the user they must use a valid email address.

The home() function

	This function requires the user to be logged in to access it. If the user is not, because it uses @login_required, if the user is not logged in and navigates to the home screen, they are redirected to the login page which prevents errors where the page cannot properly display anything since no user is logged in. This was very helpful for switching between users without having to completely change how I display posts.

	Throughout the whole function, the code iterates through a for loop of every post that has been made. This is how the program gets the information that will be displayed in the cards that I talked about in home.html. Firstly, in each iteration, the code checks to see if there is an entry in votes that relates to the particular post. This is useful for the later like/dislike actions. If there is not an entry, the code inserts a new entry into the table with the user_id of the user that is logged in, as well as the current post_id. The other 2 entries, disliked and liked, are by default set to 0 to indicate no action has been taken.

	Next, the code checks if a POST occurred. If not, it just returns the default home page with information about the posts, the comments of those posts, and the votes for those posts which are acquired via SQL and used in the html page through jinja. However, if an event occurs via POST, the code checks to see if it was a like button, dislike button, or the comment button that was pressed. Based on what the user does, either the post information, the comment information, or the vote information will be updated in final.db, and then this information will be used when the home page is rendered.

	With the like and dislike buttons, the code gets the specific id of the button so that it does not confuse the like button of the 3rd post with the like button of the 1st post. Then, it checks if the user has already liked or disliked that post. If not, it will modify the posts and votes tables, updating the number of likes/disliked and changing the boolean value of liked/disliked from false to true (from 0 to 1). If the user tries to like a post but they have already disliked the post, it switches the user’s choice from dislike to vote, or vice versa. This is checked via an if statement that checks whether or not the user has already liked or disliked the post. Then, the code updates the SQL database appropriately by getting rid of the dislike (or the like) and adding a like (or dislike) to reflect the user’s action, as well as changing the icon to display a blue thumb. Lastly, if the user has already liked a post (or disliked a post) and wants to undo that action, the user can click on the like button again (or dislike button). This is what the 3rd and 6th if statements do, checking to see if the like button for that post has already been liked, and if so, updating the database and GUI of the page so that it displays neither option as having been selected.

	With the comment button if statement, this checks if the comment button for the corresponding post has been clicked. If so, it will create the comments table if it has not been created already, and then checks what the comment_id is. If no comment id exists, it is set to 1 to indicate the first. If it does exist, 1 is added to it to make a sequence of comment ids. From there, it checks to make sure the user put a message in the input box, otherwise it returns an error. If the user did put a message into the box, that message, as well as the comment_id, the post_id, and the user_id is then added to the comments table and displayed on the home page in the corresponding post.

The profile() function

	This function gets the username of the logged in user by cross referencing the current session id with the list of usernames in the users database, giving it a match. Then, this data, as well as the information about the posts this user made, are displayed in the profile page of the user.

The newPost() function

	This function is what enables the user to make a new post. First, it checks if the user reached this page via GET or POST. If GET (aka clicks on the new post link), it brings the user to the new post page. If POST, it submits a form with the information the user wants the new post to have and uploads it to the SQL database, allowing it to be displayed on the home page. More specifically, it creates a table for the posts if one does not exist and provides the values it will need, such as the current date, the title and the message that the user input in the text fields, the user_id, the username, and the id for that post. The id for the post is determined by the same method that the comment id was determined – an if statement that checks if an id exists and if not, sets it equal to 1, otherwise increasing the value by 1. Lastly, before the program redirects the user to the home page with the updated post information, it creates the votes table if it does not exist so that the voting works properly in the home() function.